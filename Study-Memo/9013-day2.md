                                                                  **个人小结**

**一、数据库学习**

Github使用链接：https://github.com/saturn-lab/Learn-Database

参考书籍：

###### 数据库教科书：

A First Course in Database Systems, Chapter 1- Chapter 12

Database System Implementation, Chapter 13- Chapter 23

###### SQL Reference

SQLite: SQL statements, https://www.sqlite.org/lang.html

PostgreSQL: SQL Lang, https://www.postgresql.org/docs/12/sql.html

MySQL: SQL statements, https://dev.mysql.com/doc/refman/8.0/en/sql-statements.html

###### 数据库进阶实战

1. Peter Zaitsev, Vadim Tkachenko, Baron Schwartz, High Performance MySQL, Optimization, Backups, and Replication, O'Reilly Media, 3rd Edition, March 2012.
2. Enrico Pirozzi, Gregory Smith, Ibrar Ahmed, PostgreSQL 10 High Performance, Packt Publishing, 2018-04-30.

安卓手机使用SQLite数据库。

**二、实操内容**

1、使用SQLite进行实验

%load_ext sql
%sql sqlite:///

2、注意点：

Foreign Key Constraints

Foreign Keys and Delete

What happens if we delete a company? 

Three options:

1.Disallow the delete. (default)

2.Remove all products (add "on delete cascade")

3.A third variant due to NULL

**三、上午上课内容-SQL**

1、SQL JOIN 子句用于把来自两个或多个表的行结合起来，基于这些表之间的共同字段。

最常见的 JOIN 类型：**SQL INNER JOIN（简单的 JOIN）、SQL LEFT JOIN、SQL RIGHT JOIN、SQL FULL JOIN，**其中前一种是内连接，后三种是外链接。

![img](https://images2017.cnblogs.com/blog/1074709/201712/1074709-20171229165319538-1026266241.png)

INNER JOIN产生的结果集中，是1和2的交集。

LEFT JOIN返回左表的全部行和右表满足ON条件的行，如果左表的行在右表中没有匹配，那么这一行右表中对应数据用NULL代替。

RIGHT JOIN返回右表的全部行和左表满足ON条件的行，如果右表的行在左表中没有匹配，那么这一行左表中对应数据用NULL代替。

FULL JOIN 会从左表 和右表 那里返回所有的行。如果其中一个表的数据行在另一个表中没有匹配的行，那么对面的数据用NULL代替。

3、集合操作：合并、减

union，union all

4、嵌套查询

5、关系代数的优化

**四、存储引擎原理****

###### 1、Postgres 和 MySQL 比较

Postgres 和 MySQL 都有基于页面的物理存储。(8KB vs 16KB)

MySQL存储引擎MyISAM, InnoDB

MySQL： InnoDB 表结构 聚簇索引(Clustered Index)

PostgreSQL： 堆上元组（HOT, Heap Only Tuple）

2.**Logical → Physical DB**

（1）IO Model：IO模型

page的概念：页为基本单位

disk和memory

buffer：硬盘和内存的中间存储，缓存

（2）Data layout

行式和列式数据库的优缺点：

 （3）Indexing：索引

索引和数据库的性能相关

映射key到相应的行，寻找对应行的别的属性

二级索引

（4）Organizing Data and Indices

Hashing：哈希

哈希（Hash）也称为散列，就是把任意长度的输入，通过散列算法，变换成固定长度的输出，这个输出值就是散列值。

哈希表（Hash table，也叫散列表），是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。

哈希的缺点是发生碰撞。

Sorting ：排序

合并排序

外部合并算法

Counting

**3、B树与B+树**

b树（balance tree）和b+树应用在数据库索引，可以认为是m叉的多路平衡查找树，但是从理论上讲，二叉树查找速度和比较次数都是最小的，为什么不用二叉树呢？ 
因为我们要考虑磁盘IO的影响，它相对于内存来说是很慢的。数据库索引是存储在磁盘上的，当数据量大时，就不能把整个索引全部加载到内存了，只能逐一加载每一个磁盘页（对应索引树的节点）。所以我们要减少IO次数，对于树来说，IO次数就是树的高度，而“矮胖”就是b树的特征之一，它的每个节点最多包含m个孩子，m称为b树的阶，m的大小取决于磁盘页的大小。

B+ 树是一种树数据结构，是一个n叉树，每个节点通常有多个孩子，一颗B+树包含根节点、内部节点和叶子节点。B+ 树通常用于数据库和操作系统的文件系统中。 B+ 树的特点是能够保持数据稳定有序，其插入与修改拥有较稳定的对数时间复杂度。 B+ 树元素自底向上插入。

b+树相比于b树的查询优势：

1. b+树的中间节点不保存数据，所以磁盘页能容纳更多节点元素，更“矮胖”；

2. b+树查询必须查找到叶子节点，b树只要匹配到即可不用管元素位置，因此b+树查找更稳定（并不慢）；

3. 对于范围查找来说，b+树只需遍历叶子节点链表即可，b树却需要重复地中序遍历

   

   常见排序方法：

   冒泡排序，选择排序，插入排序，快速排序，堆排序，归并排序，基数排序，希尔排序，桶排序

   其中最常用的是：快速排序算法

**4、join的优化**

优化**sted Loop Joins 嵌套循环join操作

T(R) =\# of tuples in R   元组，1个页面上有多少个关系行

P(R) = \# of pages in R   页面

**连接（Join）优化: Nested Loop Join, Block Nested Loop Join, Index Nested Loop Join**

NLJ 算法:将驱动表/外部表的结果集作为循环基础数据，然后循环从该结果集每次一条获取数据作为下一个表的过滤条件查询数据，然后合并结果。如果有多表join，则将前面的表的结果集作为循环数据，取到每行再到联接的下一个表中循环匹配，获取结果集返回给客户端。

BNLJ 算法:将外层循环的行/结果集存入join buffer, 内层循环的每一行与整个buffer中的记录做比较，从而减少内层循环的次数.

INLJ算法：读取索引，降低维度 ，join 的字段有索引，MySQL 会使用 INL 算法

1. **SortMerge Join**

1. **HashPartion Joins**

   SMJ和HPJ

   

   **5、E/R模型**

High level motivation for the E/R model

Entities

Relations

ER模型必须有一个主key

**五、内容回顾**

1、Github

2、Python

3、数据库

集合Set、多集、关系代数基础

[SQL-I](https://github.com/saturn-lab/Learn-Database/blob/master/CS2)(SQL术语、数据类型、表模板、SFW、单表查询)

jupyter notebook, ipython-sql

connect db, SFW

4、[SQL-II](https://github.com/saturn-lab/Learn-Database/blob/master/CS3)(多表、JOIN连接、内连接、左连接、右连接、全连接)

single table and multiple table query

[SQL-III](https://github.com/saturn-lab/Learn-Database/blob/master/CS3)(集合操作：交集、并集；嵌套查询，子查询；)

Set Operators, Nested queries, Inner and Outer Joins

[SQL-III：Indexes ](https://github.com/saturn-lab/Learn-Database/blob/master/CS3)(聚合与Group by, Having子句，Indexes in SQL)

5、索引（Indexing）、IO模型（IO model）

外部合并（External Merge）与外部合并排序（External Merge Sort）

创建索引，B+树索引 [B+tree](https://github.com/saturn-lab/Learn-Database/blob/master/CS4/B_Plus_Trees.pdf)

哈希、排序和计数

6、连接（Join）优化: Nested Loop Join, Block Nested Loop Join, Index Nested Loop Join

连接（Join）优化: Sort Merge Join, Hash Partition JOIN

E/R模型, 数据表设计

7、事务处理Transaction

设计理论：Normal forms, Data Anomalies & Constraints, Functional Dependency

设计理论：Closures & Superkeys, Decompositions

设计理论：Boyce-Codd Normal Form